# day02

## 本章目标

* 死锁
* 信号量与PV原语
* 用PV原语解决司机与售票员问题
* 用PV原语解决民航售票问题
* 用PV原语解决汽车租赁问题

## 死锁

> 死锁：是指多个进程之间相互等待对方的资源，而在得到对方资源之前又不释放自己的资源，这样，造成循环等待的一种现象。如果所有进程都在等待一个不可能发生的事件，则进程就死锁了。

> 死锁产生的四个必要条件

* 互斥条件
  * 进程对资源进行排他性使用，即在一段时间某资源仅为一个进程所占用
* 请求和保持条件
  * 当进程因请求资源而阻塞时，对已获取的资源保持不放。
* 不可剥夺条件
  * 进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时由自己释放
* 环路等待条件
  * 各个进程组成封闭的环形链，每个进程都等待下一个进程所占用的资源

## 防止死锁办法、银行家算法和哲学家就餐问题

* 资源一次性分配：破坏请求和保持条件
* 可剥夺资源：破坏不可剥夺条件
* 资源有序分配法：破坏循环等待条件

> **死锁避免**

* 预防死锁的几种策略，会严重地损害系统性能，因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。
* 由于在避免死锁的策略中，允许进程动态地申请资源，因此，系统在进程资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，进程等待。其中最具代表性的避免死锁算法是银行家算法。

> **银行家算法**：避免死锁

* 为保证资金的安全，银行家规定：
  * 1、当一个顾客对资金的最大需求量不超过银行家现有资金时就可以接纳该顾客；
  * 2、顾客可以分期贷款，但是贷款的总数不能超过最大需求量；
  * 3、当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；
  * 4、当顾客得到所需的全部资金后，一定能在有限的时间内归还所有的资金。

> **哲学家就餐问题**：死锁产生

* 五个哲学家围在一个圆桌就餐，每个人都必须拿起两把叉子才能就餐，总共有五把叉子两个哲学家之间有一个叉子。

* 哲学家就餐问题解法：

  > [解法连接](https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin)

  * 服务生解法：找一个管理者管理叉子， 指导哲学家拿起叉子。
  * 最多四个哲学家拿起叉子：必然有一个哲学家可以就餐。[抽屉原则](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E5%88%99/4034602?fr=aladdin)
  * 仅当一个哲学家两边叉子可用时才允许他拿起叉子
  * 给所有哲学家编号，奇数号的哲学家必须首先拿起左边的叉子，偶数号的哲学家则反之。

## 信号量：P、V原语

* `信号量`和`P、V原语`由Dijkstra([迪杰斯特拉](https://baike.baidu.com/item/%E8%89%BE%E5%85%B9%E6%A0%BC%C2%B7%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB/5029407?fr=aladdin&fromid=1880870&fromtitle=Dijkstra))提出，`P、V原语`又称`P、V操作`。
* 信号量
  * 互斥：P、V在同一个进程中
  * 同步：P、V不再同一个进程中
* 信号量含义
  * S > 0：S表示可用资源的个数。
  * S = 0：表示无可用资源，无等待进程。
  * S < 0：|S|表示等待队列中进程个数。

> P、V原语
>
> * `P原语`：申请资源，如果没有进入等待，`P原语`操作是原子操作，不能被打断。
> * `V原语`：归还资源，将计数值加一，如果`V原语`之后`资源数 <= 0`，则说明有进程在等待资源，然后需要唤醒进程，使该进程变为就绪态，将其插入就绪队列。V`原语`操作是原子操作，不能被打断。
>
> P原语伪代码：原子操作，不能被打断。
>
> >PCB：进程控制块（Processing Control Block）[参考连接](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297)
>
> ```
> P(s)//申请资源
> {
>     s.value = s.value--;
>     if(s.value < 0)
>     {
>         1、该进程状态置为等待状态
>         2、将该进程的PCB插入响应的等待队列s.queue末尾
>     }
> }
> ```
>
> V原语伪代码：原子操作，不能被打断。
>
> ```
> V(s)//归还资源
> {
>      s.value = s.value++;
>     if(s.value <= 0)
>     {
>         1、唤醒响应等待队列s.queue中等待的一个进程
>         2、改变其状态为就绪态
>         3、将其插入就绪队列
>     }
> }
> ```

## 用P、V原语解决司机与售票员问题

> `P、V原语`解决同步问题
>
> > 司机进程
>
> ```
> S1(0);
> while(1)
> {
>     P(S1)//获取开车资源S1
>     启动车辆
>     正常运行
>     到站停车
>     V(S2)//释放售票资源S2
> }
> ```
>
> > 售票员进程
>
> ```
> S2(0);
> while(1)
> {
>     P(S2)//获取售票资源
>     开门
>     售票
>     关门
>     V(S1)//释放开车资源
> }
> ```

## 用P、V原语解决民航售票问题

>`P、V原语`解决互斥问题
>
>> 民航进程
>
>```
>x = 票数
>S(1);//资源只有一个
>
>P(S);//获取资源
>if(x > 0)
>	x--;
>V(S);//释放资源
>```
>
>> `4 - 7`行代码：称为临界区
>>
>> `x`：称为临界资源

## 用P、V原语解决汽车租赁问题

> 有一汽车租赁公司有两部敞篷车可以出租，假定同时来了四个顾客都要租敞篷车，那么肯定会有两个人租不到(同类资源)。
>
> ```
> S(2)
> P(S)
> 租车
> 还车
> V(S)
> ```