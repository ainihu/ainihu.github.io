# day14

> 线程开始啦

## 本章目标

* 什么是线程
* 进程与线程
* 线程优缺点
* 线程模型
  * `N：1`用户线程模型
  * `1：1`核心线程模型
  * `N：M`混合线程模型

##进程和程序

> 程序：完成特定功能的一系列有序指令的集合
>
> 可执行文件：
>
> ​	代码段 + 数据段
>
> 进程：程序的一次动态执行过程。
>
> ​	代码段 + 数据段 + 堆栈 + PCB(进程控制块：Processing Control Block)

| 进程                                   | 程序                     |
| -------------------------------------- | ------------------------ |
| 动态的                                 | 静态的                   |
| 短暂的具有生命周期，程序的动态执行过程 | 永久的                   |
| 堆栈段+PCB                             | 没有堆栈+PCB             |
| 一个进程只能对应一个此程序             | 一个程序可以对应多个进程 |
> `PCB`(Process Control Block)：进程控制块，即为系统中存放进程的管理和控制信息的数据结构称为进程控制块。

## 什么是线程

> * 在一个程序里的一个执行线路就叫做线程(thread)，更准确的定义是：线程是`一个进程内部的控制序列`
> * 一切进程至少都有一个执行线程。

## 进程与线程

> * 进程是资源竞争的基本单位
>
> * 线程是程序执行的最小单位
>
> * 线程共享进程数据，但也拥有自己的一部分数据
>
>   * 线程ID
>   * 一组寄存器
>   * 栈
>   * errno(错误码)
>   * 信号状态
>   * 优先级
>
> * 传统`UNIX`进程结构示意图
>
>   ![进程与线程](./Picture/进程与线程.png)

##fork和创建新线程的区别

> * 当一个进程执行一个fork调用的时候，会创建出进程的一个新拷贝，新进程将拥有它自己的变量和它自己的PID，这个新进程的运行时间是独立的，它在执行时几乎完全独立于创建它的进程。
> * 在进程里面创建一个新线程的时候，新的执行线程会拥有自己的堆栈(因此也就是自己的局部变量)，但要与它的创建者共享全局变量、文件描述符、信号处理器和当前的工作目录状态。

## 线程的优点

> * 创建一个新线程的代价要比创建一个新进程小得多；
> * 与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多；
> * 线程占用的资源要比进程少得多，**进程是程序执行的最小单位，线程是资源分配的最小单位**；
> * 能充分利用多处理器的可并行数量；
> * 在等待慢`I/O`操作结束的同时，程序可执行其他的计算任务；
> * 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现；
> * `I/O`密集型应用，为了提高性能，将`I/O`操作重叠。线程可以同时等待不同的`I/O`操作，线程池。

## 线程的缺点

> * 性能损失
>   * 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器，如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变
> * 健壮性降低
>   * 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
> * 缺乏访问控制
>   * 进程是访问控制的基本粒度，在一个线程中调用某些`OS函数`会对整个进程造成影响。
> * 编程难度提高
>   * 编写与调试一个多线程程序要比单线程程序困难得多。

## 线程调度竞争范围

> * 操作系统提供流各种模型，用来调度应用程序创建的线程，这些模型之间的主要不同是：在竞争系统资源(特别是CPU时间)时，线程调度竞争范围(thread-scheduling-contention scope)不一样
> * 进程竞争范围(process contention scope)：各个线程在同一进程竞争"被调度的CPU时间"(但不直接和其他进程中的线程竞争)
> * 系统竞争范围(system contention scope)：线程直接和"系统范围"内的其他线程竞争。

## 线程模型

> - `N：1`用户线程模型
>
>   - "线程实现"建立在"进程控制"机制之上，由用户空间的程序库来管理，OS内核完全不知道线程信息这写线程称为用户空间线程。
>   - 这些线程都工作在"进程竞争范围内"
>   - 在`N：1`线程模型中，内核不干涉线程的任何生命活动，也不干涉同一进程中的线程环境切换
>   - 在`N：1`线程模型中，一个进程中的多个进程只能调度到一个`CPU`，这种约束限制了可用的并行总量
>   - 第二个缺点时如果某个线程执行了一个"阻塞式"操作(如read)，那么，进程中的所有线程都会阻塞，直至那个操作结束，为次，一些线程的实现时为这些阻塞式函数提供包装器，用阻塞版本 替代这些系统调用，以消除这种限制。
>
>   ![N:1用户线程模型](./Picture/N_1用户线程模型.png)
>
> - `1：1`核心线程模型
>
>   - 在`1：1`核心线程模型中，应用程序创建的每个线程都由一个核心线程直接管理。
>
>   - `OS`内核将每一个核心线程都调在系统`CPU`上，因此所有线程都各哦工作在"系统竞争范围"。
>
>   - 这种线程的创建与调度由内核完成，因为这种线程的系统开销比较大(但一般来说，比进程开销小)。
>
>     ![1_1用户线程模型](./Picture/1_1用户线程模型.png)
>
>     ​
>
> - `N：M`混合线程模型
>
>   - `N：M`混合线程模型提供了两级控制，将用户线程映射为系统的可调度体以 实现并行，这个可调度体称为轻量级进程(LWP：lightweight process)，`LWP`再一一映射到核心线程，结合了`N:1`和`1:1`的优点。
>
>   ![N_M用户线程模型](./Picture/N_M用户线程模型.png)
>
>   ​

