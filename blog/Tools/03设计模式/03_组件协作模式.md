# 组件协作模式

* 典型模式
  * Template Method，模板方法
  * Strategy，策略模式
  * Observer / Event，事件模式

## 组件模式应用场景

### 组件协作模式

> 现代软件专业分工之后的第一个结果是 "框架与应用程序的划分"，"组件协作"模式通过晚绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

* 在软件构建过程中，对于某一项任务，它常常有稳定的整体结构，但各个子步骤却有很多改变的需求，或者由于固有的原因(比如框架与应用之间的关系)而无法和任务的整体结构同时实现。
* 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

## 代码的复用性

> 代码的复用性指的是二进制层面的复用，不是指源代码层次的复用性

## C++对多继承的态度

> C++支持多继承，但是不支持使用多继承。只希望使用的一种多继承方式，一个主继承，其它的继承为接口继承。

## 1.Template Method　模板方法

### 模式定义

> 定义一个操作中的算法的骨架(稳定)，而讲一些步骤延迟(变化)到子类中。Template Method使得自雷可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

* Template Method模式是一种非常基础性的设计模式，面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的)为很多应用程序框架提供了灵活的扩展点，是代码复用实现结构。
* 除了可以灵活应对自步骤的变化外，“不要调用我，让我来调用你” 的方向控制机构是Tempalte Method的典型应用。
* 在具体实现方面，被Tempalte Method调用的虚方法可以实现，也可以没有任何实现(抽象方法、纯虚方法)，但一般推荐将它们设置为protected方法。

## 2.Strategy　策略模式

### 动机

* 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
* 如何在运行时根据需要透明地更改对象的算法？讲算法与对象本身解耦，从而避免上述问题？

## 模式定义

> 定义一系列算法，把他们一个个封装起来，并且使它们可相互替换(变化)。该模式时算法可独立于使用它的客户程序(稳定)而变化(拓展，子类化)。

### 要点总结

* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便的根据需要在各个算法之间切换
* Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在接耦合。含有许多判断条件语句的代码通常都需要Strategy模式
* 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

## Observer/Event 观察者模式

### 动机

* 在软件构建过程中，我们需要为某些对象建立一种"通知依赖关系" ，一个对象(目标对象)的状态发生改变，所有的依赖对象(观察者对象)都将得到通知。如果这种的依赖关系过于紧密，将使软件不能很好地抵御变化。
* 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。


## 模式定义

定义对象间的一种一对多(变化)的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

## 要点总结

* 使用对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达至松耦合。
* 目标发送通知时，无需制定观察者，通知(可以携带通知信息作为参数)会自动传播。
* 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
* Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。
* 掌握抽象的通知依赖关系