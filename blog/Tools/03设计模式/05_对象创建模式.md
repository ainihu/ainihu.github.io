# 对象创建模式

> 通过"对象创建"模式绕开new，来避免对象创建(new)过程中所导致的紧耦合(**依赖具体类**)，从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

* 典型模式
  * Factory Method　工厂方法
  * Abstract Factory　抽象工厂
  * Prototype　原型模式
  * Builder　构建器

## 工厂方法

### 动机 (Motivation)

* 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。
* 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种"封装机制"来避免客户程序和这种"具体对象创建工作"的紧耦合？


### 模式定义

> 定义一个用于创建对象的接口，让自雷决定实例化哪一个类。Factory Method使得一个类的实例化延迟(目的：接耦，手段：虚函数)到子类。

### 要点总结

* Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
* Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展(而非更改)的策略，较好地解决了这种紧耦合关系。
* Factory Method模式解决"单个对象"的需求变化。确定在于要求创建方法/参数相同。

## 抽象工厂

### 动机(Motivation)

* 在软件系统中，经常面临着"一系列相互依赖的对象"的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。
* 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种"封装机制"来避免客户程序和这种"多系列具体对象创建工作"的紧耦合？

### 模式定义

> 提供一个接口，让该接口负责创建一系列"相关或者相互依赖的对象"，无需指定它们具体的类。	

### 要点总结

* 如果没有应对"多系列对象构建"的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。
* "系列对象"指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
* Abstract Factory模式主要在于应对"新系列"的需求变动。其缺点在于难以应对"新对象"的需求变动。

## 原型模式

### 动机(Motivation)

* 在软件系统中，经常面临着"某些结构复杂的对象"的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。
* 如何应对这种变化？如何向"客户程序(使用这些对象的程序)"隔离出"这些易变对象"，从而使"依赖这些易变对象的客户程序"不随着需求改变而改变？

### 模式定义

> 使用原型实例制定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

### 要点总结

* Prototype模式同样用于隔离类对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些"易变类"拥有"稳定的接口"
* Prototype模式对于"如何创建易变类的实体对象"采用"原型克隆"的方法来做，它使得我们可以非常灵活地动态创建"拥有某些稳定接口"的新对象---所需工作仅仅是注册一个新类的对象(即原型)，然后在任何需要的地方Clone。
* Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。

## 构建器

### 动机(Motivation)

* 在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一个的算法却相对稳定。
* 如何应对这种变化？如何提供一种"封装机制"来隔离出"复杂对象的各个部分"的变化，从而保持系统中的"稳定构建算法"不随着需求变化而变化？

### 模式定义

> 将一个复杂对象的构建与表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。

### 要点总结

* Builder模式主要用于"分步骤构建一个复杂的对象"。在这其中"分步骤"是一个稳定的算法，而复杂对象的各个部分则经常变化。
* 变化点在哪里，封装哪里－－Builder模式主要在于应对"复杂对象各个部分"的频繁需求变动。其缺点在于难以应对"分步骤构建算法"的需求变动。
* 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别。