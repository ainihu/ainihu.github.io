# 状态模式

* 在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？"状态变化"模式为这一问题提供了一种解决方案。
* 典型模式
  * State
  * Memento

## 状态模式

### 动机(Motivation)

* 在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。
* 如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化引入紧耦合？


### 模式定义

> 允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。

### 要点总结

* State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。
* 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转化是原子性的－－即要么彻底转换过来，要么不转换。
* 如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。

## 备忘录模式

### 动机(Motivation)

* 在软件构建过程中，某些对象的状态在转换过程中，可能由于某钟需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公共接口来让其他对象得到对象的状态，便会暴露对象的细节实现。
* 如何实现对象状态的良好保存于恢复？但同事又不会因此而破坏对象本身的封装性。

### 模式定义

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

### 要点总结

* 备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。
* Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要讲状态保持到外接(Memento)
* 由于现代语言运行时(如C#、Java等)都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。