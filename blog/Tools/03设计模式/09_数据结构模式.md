# 数据结构模式

* 常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外界提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。
* 典型模式
  * Composite
  * Iterator
  * Chain of Resposibility

## 组合模式

### 动机(Motivation)

* 在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。
* 如何将"客户代码与复杂的对象容器结构"解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？

### 模式定义

> 将对象组合成**树状结构**以表示"部分-整体"的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性(稳定性)。

### 要点总结

* Composite模式采用树形结构来实现普遍存在的对象容器，从而将"一对多"的关系转化为"一对一"的关系，使得客户代码可以一致地(复用)处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。
* 将"客户代码与复杂的对象容器结构"解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口－－而非对象容器的内部实现结构－－发生依赖，从而更能"应对变化"。
* Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。

## 迭代器模式

### 动机(Motivation)

* 在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种"透明遍历"也为"同一种算法在多种集合对象上进行操作"提供了可能。
* 使用面向对象技术将这种遍历机制抽象为"迭代器对象"为"应对变化中的集合对象"提供了一种优雅的方式。

### 模式定义

> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象内部表示。

### 要点总结

* 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
* 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
* 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

## 职责链

### 动机(Motivation)

* 在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地打来请求发送者与接受者的紧耦合。
* 如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。

### 模式定义

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

### 要点总结

* Chain of Responsibility模式的应用场合在于"一个请求可能有多个接收者，但是最后真正的接受者只有一个"，这时候请求发送者与接收者的耦合有可能出现
  "变化脆弱"的症状，职责链的目的就是将二者解耦，从而更好地应对变化。
* 应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在行动时动态添加/修改请求的处理职责。
* 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。

