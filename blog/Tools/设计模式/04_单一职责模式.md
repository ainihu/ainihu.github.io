# 单一职责模式

[TOC]

> 在软件组织的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，自雷几句膨胀，同时充斥着重复代码，这时候的关键是划清责任。**重要手段：继承转组合。**

* 典型模式
  * Decorator，装饰模式
  * Bridge，桥模式

## Decorator 装饰模式

### 动机

* 在某些情况下我们可能会"过度地使用继承来拓展对象的功能"，由于继承为类型引入的静态特质，使得这种拓展方式缺乏灵活性；并且随着子类的增多(扩展功能的增多)，各种子类的组合(扩展功能的组合)会导致更多子类的膨胀。
* 如何使"对象功能的扩展"能够根据需要来动态地实现？同时避免"扩展功能的增多"带来的子类膨胀问题？从而使得任何"功能扩展变化"所导致的影响降为最低？

### 要点总结

* 通过采用组合而非继承的手法，Decorator模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的"灵活性差"和"多子类衍生问题"。
* Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外的一个Component类。
* Decorator模式的目的并非解决"多子类衍生的多继承"问题，Decorator模式应用的要点在于结局"主体类在多个方向上的扩展功能"－－是为"装饰"的含义。
* 遇到继承一个类，又组合了这个类，第一反应装饰模式。继承为了完善接口的规范，组合类是为了将来实现具体的实现类(多态)。

## Bridge 桥模式

### 动机(Motivation)

* 由于某些类型的固有的实现逻辑，使得它们具有两个变化的唯独，乃至多个唯独的变化
* 如何应对这种"多维度的变化"？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？


### 模式定义

> 讲抽象部分(业务功能)于实现部分(平台实现)分离，使它们都可以独立地变化。

### 要点总结

* Bridge模式使用"对象间的组合关系"解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即"子类化"它们。
* Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。
* Bridge模式的应用一般在"两个非常强的变化维度"，有时一个类也有多个的变化维度，这时可以使用Bridge的扩展模式。